Sorry if you don't like my symbols (using some regex stuff because I am lazy).
All whitespace is ignored, meaning that any spaces in the grammar may also be
replaced by any number (including zero) of spaces.

An underscore program obeys the rules for <sections>.

<sections>::=(<statement>|<expression>|<control>|<comment>|<return>)*
<statement>::=<reference> ' = ' <expression>
<single_name>::=(<letter>|'_') (<letter>|<digit>|'_')*
<letter>::=[a-z][A-Z]
<digit>::=[0-9]
<expression>::=(<addition>|<subtraction>|<term>|<boolean_expression>)' ; '
<object>::=<integer>|<float>|<boolean>|<string>|<none>|<template>|<reference>|<function>
<integer>::=[+-]?<digit>+
<float>::=[+-]?<digit>+ '.' <digit>+
<boolean>::='true'|'false'
<string>::="'"<character>*"'"|'"'<character>*'"'|"'''"<character>*"'''"|'"""'<character>*'"""'
<none>::='none'
<template>::='template ' <passable_names>? '{ ' <sections> ' } '
<passable_names>::= ' ( ' ( <single_name> (', ' <single_name>)* )? ' ) '
<reference>::=(<single_name>|<template_instantiation>|<function_call>)('.'(<single_name>|<template_instantiation>|<function_call>))*
<reference>::=(<single_name>|<template_instantiation>|<function_call>)('['<expression>']')*
<template_instantiation>::=(<template>|<single_name>)? <passable_expressions>
<passable_expressions>::= ' ( ' ( <expression> (', ' <expression>)* )? ' ) '
<function_call>::=(<function>|<single_name>)? <passable_expressions>
<function>::='function ' <passable_names> '{ ' <sections> ' } '
(<statement>|<expression>|<control>|<comment>|<return>)*
<return>::='return ( ' <expression_without_semi_colon> ' ) ; '
<expression_without_semi_colon>::=<object>|<addition>|<subtraction>|<term>|<boolean_expression>
<addition>::=<term> ' + ' (<term>|<addition>|<subtraction>)
<term>::=<multiplication>|<division>|<non_expandable_term>
<multiplication>::=<non_expandable_term> ' * ' <term>
<non_expandable_term>::=('(' <expression_without_semi_colon> ')')|<object>
<division>::=<non_expandable_term> ' / ' <term>
<subtraction>::=<term> ' - ' (<term>|<addition>|<subtraction>)
<boolean_expression>::=(' NOT ')?<boolean_statement>((' AND '|' OR ')(' NOT ')?<boolean_statement>)*
<boolean_statement>::=<non_boolean_expression>(' == '|' <= '|' < '|' >= '|' > '|' != ')<non_boolean_expression>
<non_boolean_expression>::=(<object>|<addition>|<subtraction>|<term>|)
<control>::=(<if>|<while>)' ; '
<if>::='if ( ' <expression> ' ) { ' <sections> ' }' (' else ( ' <expression> ' ) { ' <sections> ' }')?
<while>::='while (' <expression> ') {' <sections> '}'
<comment>::=' #' .* '# '

Please note that there are reserved words that cannot be a single_name. These
are:
    if
    else
    while
    template
    function
    return
    true
    false
    none
    break
    continue
    float
    integer
    boolean
    string

There are also read-only names, that cannot be assigned to:
    container
    set
    get
    delete

Also note that the set() standard method can be used to (and is intended to be
able to) override these restrictions (only within templates though).
